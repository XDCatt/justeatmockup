# Restaurant Finder
A Flutter mobile app mockup for the Just Eat Takeaway.com coding assignment.

## Demo Screenshots
- Search for PostCode
  <img height="400" src="resources/postcode_search.jpg" width="180">
- Color Distinguish Rating Level of Restaurants
  <img height="400" src="resources/color.jpg" width="180"/>
- Error Handling ofr Data Fetch
  <img height="400" src="resources/error_handling.jpg" width="180"/>

## How to Run
1. Install Flutter (see [official docs](https://flutter.dev/docs/get-started/install)).
2. Clone this repo: `git clone <your-repo-url>`.
3. Navigate to the folder: `cd restaurant_finder`.
4. Install dependencies: `flutter pub get`.
5. Launch an emulator: `flutter emulators --launch <emulator-id>`.
6. Run the app: `flutter run`.

## Assumptions
- Hardcoded default postcode "SW1A1AA" for simplicity.
- Used `address.firstLine` for the address field; Next step: expand to include city/postcode.
- Assumed `cuisines` contains relevant names despite some being tags (e.g., "Deals").

## Implementations
This Flutter app fetches restaurant data from the Just Eat Takeaway.com API and displays the first 10 restaurants in a mobile-friendly interface. Below are the key implementation details:

### Project Structure
``` MVVM architecture
lib/
├─ services/                          
|    ├─ user_location_service.dart   // Native
│    └─ restaurant_service.dart   // Only handles HTTP, decoding, and logging.
|
├─ repositories/                  // business logic, mapping, caching
|    ├─ user_location_repository.dart
│    └─ restaurant_repository.dart       
|
├─ models/
|    ├─ rating.dart
|    ├─ address.dart
|    ├─ location.dart           //Nested Location model for the coordinates fetched from API, 
|    |                            // and `toGeoPoint()`` function which returns the cloud_firestore/GeoPoint type from Firebase
|    └─ restaurant.dart          // generated by json_serializable
|
├─ screens/                   // UI View
│    └─ features/
|        ├─ widgets/          // local widgets specific to this feature screen
│        └─ restaurant_screen.dart 
| 
├─ widgets/                  // Shared widgets
|    ├─ main_button.dart
|    ├─ user_location_aware.dart
|    ├─ error_card.dart
|    └─ search_bar.dart   
|
├─ util/ 
|    └─ geo_utils.dart         // Added a GeoUtil file to calculate the distance  between two geographical points using the Haversine formula
|
└─ errors/
     ├─ failure.dart       // Abstract Failure class
     └─ location_failure.dart        

```
#### Data Layer 
References from Flutter official [docs](https://docs.flutter.dev/app-architecture/case-study/data-layer)

**`Service`** are stateless Dart classes that interact with APIs, such as:
  - REST APIs
  - Databases
  - OS services like Contacts/Calendar
  - Hardware features like location and acceleration sensors

There's generally one service class per data source, its only job is to wrap an external API.

**`Repositories`**: 
 - It should be the only place where that data type is mutated, namely we convert data from/to the external data format (e.g., JSON) to domain objects, implementing business logic. 
 - Business logic is also implemented here, for example the `restaurants` array is limited to the first 10 entries using `.take(10)`.
 - Repositories are also responsible for synchronizing the data when offline capabilities are supported, managing retry logic, and caching data.

**`Models`**: Data objects, Keep alignment of domain objects within the app, procide to/from JSON that Repositories can use.
 - Specifically, I used `json_serializable` to auto-generate code for serialize/deserialize, since there're nested objects included.
 - Create Location model for the coordinates fetched from API, and `toGeoPoint()`` function which returns the cloud_firestore GeoPoint type from Firebase
2. Added a GeoUtil file to calculate the distance  between two geographical points using the Haversine formula

#### UI Layer
**`Screens`**: Full Page or high-level Widget that fully implements a specific feature.
  - Organized by features or screen function.
  - A feature folder contains all the widgets, screen layout needed for that feature.

**`Errors`**: Error handling with all exceptions through an abstract `Failure` base class, then extends each concrete case as immutable subclasses (e.g.,  `LocationServiceDisabledFailure, LocationPermissionDeniedFailure, PlatformFailure`) so every layer can pattern-match errors in a type-safe, centralized way.

**`Widgets`**: Include all widgets used on more than one page.
- User Location Aware Widget: A widget that provides the user's native location to its child widget

### UI Design
- Widget Choice: A FutureBuilder manages the asynchronous API call, displaying a loading spinner, error message, or the restaurant list based on the state.
- Restaurant Display: Each restaurant is shown in a Card widget with:
name in bold as the title.
address, rating, and cuisines listed vertically below.
cuisines joined into a comma-separated string (e.g., "Burgers, Chicken, Halal").
- Styling: Basic padding and font adjustments ensure a clean, readable layout.

### Error Handling
- Uses null-safe operators (?., ??) to handle missing or null fields gracefully.
- HTTP-level exceptions are caught and translated to `Failure` subclasses inside the stateless Service, the Repository just forwards those domain-level failures, and the View layer catches them to show user-friendly messages.

### Key Decisions
- Nested Models: Added `Address`, `Location`, and `Rating` models for better structure and reusability.
- Hardcoded Postcode: Chose "SW1A1AA" to focus on displaying data rather than building an input system, per the assignment’s emphasis on presentation.
- Minimal Dependencies: Only added http to keep the app lightweight.
- Card Layout: Opted for Card over ListTile for a more modern, mobile-app aesthetic.

## Improvements
- [x] Add a text field for user-input postcodes and fetch the corresponding location.
- [x] Enhance UI with colors or icons (e.g., star for rating).
- [ ] Add a ViewModel layer, which includes the user intention logic, managing the `states` , leaving the widgets from View layer only for rendering.
- [ ] Add unittests and mock tests, for now there' re only two mock tests as example.
- [ ] Set the default postcode based on user location.
- [ ] I hardcoded base_url, should introduce `flutter_dotenv` to hold secrets